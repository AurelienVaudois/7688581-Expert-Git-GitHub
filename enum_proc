from enum import Enum
from pydantic import BaseModel, Field
from typing import List, Optional, Literal

# Reconstitution de la hi√©rarchie d'apr√®s vos images (Liste non exhaustive √† compl√©ter)
class CodePouvoir(str, Enum):
    # --- NIV 1 : TOUT POUVOIR ---
    TOUT_POUVOIR = "TOUT POUVOIR"
    TOUT_POUVOIR_DELEGATION = "TOUT POUVOIR PAR DELEGATION"
    TOUT_POUVOIR_RESTRICTION = "TOUT POUVOIR RESTRICTION COMPTE"
    
    # --- CONTRATS ---
    SIGNER_RESILIER_TOUT_CONTRAT = "SIGNER/RESILIER TOUT CONTRAT"
    SIGNER_CONVENTION_COMPTE = "SIGNER/RESILIER CONVENTION DE COMPTE"
    SIGNER_CONTRAT_EBANKING = "SIGNER/RESILIER CONTRAT EBANKING"
    SIGNER_CONTRAT_CASH_POOLING = "SIGNER/RESILIER CONTRAT CASH POOLING"
    
    # --- PAIEMENTS AU DEBIT (L'exemple le plus fr√©quent) ---
    SIGNER_TOUT_PAIEMENT_DEBIT = "SIGNER TOUT PAIEMENT AU DEBIT"
    
    # Virements Tiers
    SIGNER_TOUT_VIREMENT_TIERS = "SIGNER TOUT VIREMENT TIERS"
    SIGNER_VIREMENT_DOMESTIQUE = "SIGNER VIREMENT TIERS DOMESTIQUE"
    SIGNER_VIREMENT_SEPA = "SIGNER VIREMENT TIERS SEPA"
    SIGNER_VIREMENT_INTERNATIONAL = "SIGNER VIREMENT TIERS INTERNATIONAL"
    
    # Autres d√©bits
    SIGNER_VIREMENT_TRESORERIE = "SIGNER TOUT VIREMENT TRESORERIE"
    SIGNER_VIREMENT_SALAIRE = "SIGNER TOUT VIREMENT SALAIRE"
    SIGNER_CHEQUE_EMIS = "SIGNER CHEQUE EMIS"
    
    # --- ENCAISSEMENT ---
    SIGNER_TOUT_ENCAISSEMENT = "SIGNER TOUT ENCAISSEMENT"
    ENDOSSER_EFFET_COMMERCE = "ENDOSSER/SIGNER TOUT EFFET DE COMMERCE"
    ENDOSSER_CHEQUE = "ENDOSSER/SIGNER DEPOT CHEQUE"
    
    # --- FINANCEMENT / CREDIT DOC ---
    SIGNER_AVIS_TIRAGE = "SIGNER TOUT AVIS DE TIRAGE LIE A UN FINANCEMENT"
    SIGNER_CREDIT_DOC_IMPORT = "SIGNER TOUTE OPERATION LIEE AU TRAITEMENT DE CREDIT DOCUMENTAIRE IMPORT"
    SIGNER_CREDIT_DOC_EXPORT = "SIGNER TOUTE OPERATION LIEE AU TRAITEMENT DE CREDIT DOCUMENTAIRE EXPORT"
    
    # Valeur par d√©faut si le mod√®le ne trouve pas de correspondance
    AUTRE = "AUTRE / NON SPECIFIE"

++++++ pydantic +++++++

class PouvoirStandardise(BaseModel):
    # C'est ici que la magie op√®re : le mod√®le doit choisir dans la liste
    categorie_standard: CodePouvoir = Field(
        ..., 
        description="Le code standard qui correspond le mieux au pouvoir d√©crit dans le document."
    )
    texte_original: str = Field(..., description="Le texte exact tel qu'il appara√Æt dans le PDF (pour audit).")
    
    # Attributs du pouvoir
    comptes_concernes: List[str] = Field(..., description="Liste des comptes ou 'TOUS'")
    
    strategie_signature: Literal["SEULE", "CONJOINTE", "NON PRECISEE"] = Field(
        ..., description="La strat√©gie de signature."
    )
    
    plafond_montant: Optional[float] = Field(None, description="Montant du plafond (ex: 100000.0)")
    plafond_devise: Optional[str] = Field(None, description="Devise du plafond (ex: EUR)")
    
    delegation_possible: bool = Field(False, description="Le pouvoir peut-il √™tre d√©l√©gu√© ?")

class Mandant(BaseModel):
    nom: str
    prenom: str
    profession: Optional[str] = None
    signature_presente: bool = Field(..., description="La signature du mandant est-elle visible ?")

class Mandataire(BaseModel):
    nom_usage: Optional[str] = None
    nom_naissance: Optional[str] = None
    prenom: str
    date_naissance: Optional[str] = Field(None, description="Format JJ/MM/AAAA")
    profession: Optional[str] = None
    college: Optional[str] = Field(None, description="Groupe d'appartenance (Coll√®ge A, B...)")
    signature_presente: bool = Field(..., description="La signature est-elle visible ?")

class ProcurationStructuree(BaseModel):
    objet_procuration: str
    societe_raison_sociale: str
    societe_siren: Optional[str]
    numero_compte_principal: Optional[str]
    
    mandants: List[Mandant]
    mandataires: List[Mandataire]
    
    # Liste des pouvoirs mapp√©s
    pouvoirs: List[PouvoirStandardise]

+++++++ prompt +++++++

def get_system_prompt_mapping():
    # On r√©cup√®re la liste des choix possibles pour l'injecter dans le texte du prompt
    liste_pouvoirs = [e.value for e in CodePouvoir]
    
    return f"""
    Tu es un analyste bancaire expert.
    
    TA MISSION :
    1. Extraire les entit√©s (Mandants, Mandataires, Soci√©t√©).
    2. Analyser les pouvoirs bancaires et faire un **MAPPING INTELLIGENT**.
    
    INSTRUCTIONS DE MAPPING DES POUVOIRS :
    Le document contient des descriptions de pouvoirs (ex: "Peut signer des virements SEPA").
    Tu dois associer chaque pouvoir trouv√© √† l'une des **Cat√©gories Standards** ci-dessous.
    
    LISTE DES CAT√âGORIES STANDARDS (Niveau 1, 2 et 3) :
    {json.dumps(liste_pouvoirs, indent=2, ensure_ascii=False)}
    
    R√àGLES :
    - Si le document dit "Virements SEPA", choisis "SIGNER VIREMENT TIERS SEPA".
    - Si le document est vague ("Virements"), choisis le niveau sup√©rieur "SIGNER TOUT VIREMENT TIERS".
    - Si tu vois un tableau, respecte bien la ligne du compte et la colonne de la strat√©gie (Seule/Conjointe).
    - Pour "Coll√®ge", cherche une mention type "Coll√®ge A" ou "Groupe 1" √† c√¥t√© du nom du mandataire.
    """

# Dans votre fonction d'appel API :
# system_prompt = get_system_prompt_mapping()
# ...

+++++++++ prompt ++++++

import json
from openai import OpenAI

# Configuration Client (vLLM sur H100)
client = OpenAI(base_url="http://localhost:8000/v1", api_key="EMPTY", timeout=300)

def analyze_procuration_strict(pdf_path):
    # 1. Conversion des images (Utilisez votre fonction existante qui marche)
    # user_content = prepare_images_content(pdf_path) 
    # Pour l'exemple, supposons que vous avez d√©j√† `user_content`
    # (Si besoin je vous remets le code de conversion, mais vous sembliez l'avoir)
    
    # 2. G√©n√©ration du Sch√©ma JSON pour le guidage
    # Cela transforme nos classes Python en un sch√©ma que l'IA comprend
    json_schema = ProcurationSchema.model_json_schema()
    
    # 3. R√©cup√©ration de la liste des choix pour le prompt texte
    # On aide le mod√®le en lui listant les choix possibles en texte clair aussi
    liste_choix = [e.value for e in CodePouvoir]

    # 4. Prompt Syst√®me "Augment√©"
    system_prompt = f"""
    Tu es un expert bancaire. Analyse cette procuration.
    
    MISSION DE MAPPING :
    Le document contient des descriptions de pouvoirs (ex: "Peut signer des ch√®ques").
    Tu dois obligatoirement classer chaque pouvoir dans l'une des cat√©gories standards ci-dessous.
    
    LISTE DES CAT√âGORIES AUTORIS√âES :
    {json.dumps(liste_choix, indent=2, ensure_ascii=False)}
    
    R√àGLES D'EXTRACTION :
    - **Coll√®ge** : Si un mandataire appartient au "Coll√®ge A" ou "Groupe B", extrais-le.
    - **Strat√©gie** : "SEULE" ou "CONJOINTE" (avec qui ?).
    - **Mapping** : Si le texte dit "Virement SEPA", choisis "SIGNER VIREMENT TIERS SEPA".
      Si le texte est vague ("Virements"), prends le niveau sup√©rieur "SIGNER TOUT VIREMENT TIERS".
    """

    print("üöÄ Envoi au mod√®le Qwen sur H100 avec Mapping Strict...")

    try:
        response = client.chat.completions.create(
            model="Qwen/Qwen2-VL-72B-Instruct-AWQ", # Votre ID mod√®le exact
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_content} # Vos images base64
            ],
            temperature=0.01, # Tr√®s faible pour √©viter qu'il invente des cat√©gories
            max_tokens=4096,
            # C'est la cl√© : on force la structure de sortie
            extra_body={
                "guided_json": json_schema
            }
        )

        # 5. Parsing et Validation
        raw_json = response.choices[0].message.content
        clean_json = raw_json.replace("```json", "").replace("```", "").strip()
        
        # Validation Pydantic automatique
        # Si une cat√©gorie est invent√©e par le mod√®le, cette ligne plantera (c'est ce qu'on veut)
        data_struct = ProcurationSchema.model_validate_json(clean_json)
        
        return data_struct

    except Exception as e:
        print(f"‚ùå Erreur : {e}")
        # En cas d'erreur Pydantic, on peut vouloir voir le JSON brut pour comprendre
        if 'raw_json' in locals():
            print("--- JSON Brut re√ßu (Invalide) ---")
            print(raw_json)
        return None
