#!/usr/bin/env python3
# coding: utf-8
"""
Évalue des couples *_ref.json / *_pred.json dans le dossier `json/`
– indépendamment de l’ordre des listes –
et écrit results.csv
"""
from pathlib import Path
import json, re, csv, hashlib
from decimal import Decimal
from datetime import date
from collections import Counter
from typing import Any, Dict

# ----------------------------------------------------------------------
# 1) Normalisation (comme avant)
# ----------------------------------------------------------------------
date_rx = re.compile(r"(\d{1,2})\s*[/-]\s*(\d{1,2})\s*[/-]\s*(\d{2,4})")
num_rx  = re.compile(r"[+-]?\d+(?:[.,]\d+)?")

def fix_scalar(x: Any) -> Any:
    if isinstance(x, str):
        s = x.strip()
        if num_rx.fullmatch(s.replace(" ", "")):
            return Decimal(s.replace(" ", "").replace(",", "."))
        m = date_rx.fullmatch(s)
        if m:
            d, m_, y = map(int, m.groups())
            if y < 100:
                y += 2000
            return date(y, m_, d)
        return s.lower()
    return x

def normalize(obj: Any) -> Any:
    if isinstance(obj, dict):
        return {k: normalize(v) for k, v in sorted(obj.items())}
    if isinstance(obj, list):
        return [normalize(v) for v in obj]
    return fix_scalar(obj)

# ----------------------------------------------------------------------
# 2) Clé stable pour un élément de liste
# ----------------------------------------------------------------------
def elem_key(elem: Any) -> str:
    js = json.dumps(elem, sort_keys=True, default=str)
    return hashlib.md5(js.encode()).hexdigest()[:8]

# ----------------------------------------------------------------------
# 3) Flatten sans sensibilité à l’ordre des listes
# ----------------------------------------------------------------------
def flatten(obj: Any, prefix: str = "") -> Dict[str, Any]:
    out: Dict[str, Any] = {}

    if isinstance(obj, dict):
        for k, v in obj.items():
            out.update(flatten(v, f"{prefix}.{k}" if prefix else k))

    elif isinstance(obj, list):
        # on regroupe par hash pour ignorer l'ordre
        buckets: Dict[str, list] = {}
        for item in obj:
            h = elem_key(item)
            buckets.setdefault(h, []).append(item)

        for h, items in buckets.items():
            for idx, v in enumerate(items):
                out.update(flatten(v, f"{prefix}[{h}#{idx}]"))

    else:  # scalaire
        out[prefix] = obj

    return out

# ----------------------------------------------------------------------
# 4) Scoring pour un couple
# ----------------------------------------------------------------------
def score_pair(path_gt: Path, path_pred: Path) -> Dict[str, Any]:
    flat_gt   = flatten(normalize(json.loads(path_gt.read_text())))
    flat_pred = flatten(normalize(json.loads(path_pred.read_text())))

    expected, predicted = set(flat_gt), set(flat_pred)
    common              = expected & predicted

    correct = sum(1 for k in common if flat_gt[k] == flat_pred[k])
    extra   = len(predicted - expected)
    score   = correct - extra
    total   = len(expected)

    return {
        "id"            : path_gt.stem.split("_")[0],
        "total_fields"  : total,
        "correct"       : correct,
        "wrong_missing" : total - correct,
        "extra_keys"    : extra,
        "score"         : score,
        "ratio"         : round(score / total, 4),
    }

# ----------------------------------------------------------------------
# 5) Découverte des couples *_ref / *_pred
# ----------------------------------------------------------------------
def discover_pairs(root: Path):
    for gt in root.glob("*_ref.json"):
        pred = gt.with_name(gt.name.replace("_ref.json", "_pred.json"))
        if pred.exists():
            yield gt, pred

# ----------------------------------------------------------------------
# 6) Main
# ----------------------------------------------------------------------
def main(json_dir="json", out_csv="results.csv"):
    root = Path(json_dir)
    rows = [score_pair(gt, pred) for gt, pred in discover_pairs(root)]
    if not rows:
        print("⚠️  Aucun couple détecté dans", root.resolve())
        return

    with open(out_csv, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=list(rows[0].keys()))
        writer.writeheader()
        writer.writerows(rows)

    print(f"✅  {len(rows)} couples évalués – résultats : {out_csv}")

if __name__ == "__main__":
    main()
