import gradio as gr
import time # Juste pour simuler un petit d√©lai de traitement

# 1. Fonction de classification "vanilla" (placeholder)
def classify_email_placeholder(email_text):
    """
    Fonction de d√©monstration qui simule la classification d'un email.
    Prend le texte de l'email en entr√©e et retourne des donn√©es factices
    pour les cat√©gories candidates, les exemples et la pr√©diction finale.
    """
    print(f"Traitement de l'email : {email_text[:50]}...") # Affiche le d√©but de l'email dans la console

    # Simule un petit temps de traitement
    time.sleep(1)

    # Logique de classification factice :
    # Pour cette d√©mo, on retourne toujours les m√™mes valeurs.
    # Vous remplacerez cette partie par votre vraie logique de classification.
    if not email_text or len(email_text.strip()) == 0:
        return "N/A", "N/A", "Veuillez entrer le texte d'un email."

    candidate_categories = "Commercial (Score: 0.6), Personnel (Score: 0.3), Spam (Score: 0.1)"
    candidate_examples = "Exemple 1 (similaire), Exemple 2 (diff√©rent), Exemple 3 (spam)"
    final_prediction = "Commercial" # La cat√©gorie jug√©e la plus probable

    print("Classification termin√©e.")

    # Retourne les trois valeurs qui correspondent aux composants de sortie d√©finis dans l'interface
    return candidate_categories, candidate_examples, final_prediction

# 2. Cr√©ation de l'interface Gradio
with gr.Blocks() as demo:
    gr.Markdown("# Classificateur d'Emails")
    gr.Markdown("Collez le contenu d'un email ci-dessous et cliquez sur 'Classifier' pour obtenir une pr√©diction de cat√©gorie.")

    with gr.Row():
        # Zone de saisie pour l'email
        email_input = gr.Textbox(
            lines=10,
            label="Email √† classifier",
            placeholder="Collez ici le contenu complet de l'email..."
        )

    # Bouton pour soumettre
    submit_button = gr.Button("Classifier l'Email")

    gr.Markdown("---") # S√©parateur visuel
    gr.Markdown("## R√©sultats de la classification")

    with gr.Row():
        # Zone de sortie pour les cat√©gories candidates
        output_categories = gr.Textbox(label="Cat√©gories candidates (avec scores simul√©s)")

        # Zone de sortie pour les exemples candidats
        output_examples = gr.Textbox(label="Exemples candidats (simul√©s)")

    # Zone de sortie pour la pr√©diction finale
    output_prediction = gr.Textbox(label="Pr√©diction finale de la cat√©gorie")

    # 3. Lier le bouton √† la fonction
    # Quand le bouton est cliqu√©, la fonction 'classify_email_placeholder' est appel√©e
    # avec le contenu de 'email_input' comme argument.
    # Les valeurs retourn√©es par la fonction sont affich√©es dans les composants de sortie
    # dans l'ordre sp√©cifi√© dans la liste 'outputs'.
    submit_button.click(
        fn=classify_email_placeholder,
        inputs=email_input,
        outputs=[output_categories, output_examples, output_prediction]
    )

# 4. Lancer l'application web
if __name__ == "__main__":
    demo.launch()


#################### V2 ################################################################

import gradio as gr
import time
import json # Import json pour une meilleure manipulation potentielle, bien que Gradio le g√®re souvent automatiquement

# 1. Fonction de classification mise √† jour
def classify_email_placeholder(email_text, top_k, nb_ex_par_categorie):
    """
    Fonction de d√©monstration mise √† jour qui simule la classification d'un email.
    Prend le texte de l'email, top_k et nb_ex_par_categorie en entr√©e.
    Retourne la pr√©diction finale (string) et les cat√©gories/exemples candidats (dictionnaires/listes Python pour JSON).
    """
    print(f"Traitement de l'email : {email_text[:50]}...")
    print(f"Param√®tres re√ßus : top_k={top_k}, nb_ex_par_categorie={nb_ex_par_categorie}")

    # Simule un petit temps de traitement
    time.sleep(1)

    # Logique de classification factice :
    if not email_text or len(email_text.strip()) == 0:
        # Retourne des valeurs vides/par d√©faut pour les sorties JSON et un message pour la pr√©diction
        return "Veuillez entrer le texte d'un email.", {}, {}

    # Simuler la g√©n√©ration de cat√©gories candidates bas√©es sur top_k
    # Normalement, votre mod√®le retournerait une liste tri√©e de (cat√©gorie, score)
    all_categories = [
        ("Commercial", 0.65),
        ("Personnel", 0.25),
        ("Spam", 0.05),
        ("Promotion", 0.03),
        ("Important", 0.02)
    ]
    # S√©lectionne les top_k cat√©gories
    candidate_categories_list = sorted(all_categories, key=lambda item: item[1], reverse=True)[:int(top_k)]
    # Formatte en dictionnaire pour la sortie JSON
    candidate_categories_json = {cat: score for cat, score in candidate_categories_list}

    # Simuler la g√©n√©ration d'exemples candidats bas√©s sur nb_ex_par_categorie
    # Cr√©e un dictionnaire o√π chaque cl√© est une cat√©gorie candidate
    # et la valeur est une liste d'exemples simul√©s.
    candidate_examples_json = {}
    for cat, score in candidate_categories_list:
        examples = [f"Exemple {cat} #{i+1} (similaire)" for i in range(int(nb_ex_par_categorie))]
        candidate_examples_json[cat] = examples

    # D√©termine la pr√©diction finale (la plus probable des candidates)
    if candidate_categories_list:
        final_prediction = candidate_categories_list[0][0]
    else:
        final_prediction = "Inconnue"

    print("Classification termin√©e.")
    print(f"Prediction: {final_prediction}")
    print(f"Categories Candidates (JSON): {candidate_categories_json}")
    print(f"Exemples Candidates (JSON): {candidate_examples_json}")


    # IMPORTANT: L'ordre de retour doit correspondre √† l'ordre dans la liste 'outputs' de .click()
    # Ordre souhait√© : Pr√©diction finale, Cat√©gories JSON, Exemples JSON
    return final_prediction, candidate_categories_json, candidate_examples_json

# 2. Cr√©ation de l'interface Gradio
with gr.Blocks() as demo:
    gr.Markdown("# Classificateur d'Emails")
    gr.Markdown("Collez le contenu d'un email, ajustez les param√®tres si besoin, et cliquez sur 'Classifier'.")

    with gr.Row():
        # Zone de saisie pour l'email
        email_input = gr.Textbox(
            lines=10,
            label="Email √† classifier",
            placeholder="Collez ici le contenu complet de l'email..."
        )

    # --- NOUVEAU : Param√®tres au-dessus du bouton ---
    gr.Markdown("### Param√®tres de Classification")
    with gr.Row():
         # Slider pour top_k
        top_k_slider = gr.Slider(
            minimum=1,
            maximum=10,
            value=3, # Valeur par d√©faut
            step=1,
            label="Top K Cat√©gories",
            info="Nombre de cat√©gories les plus probables √† afficher."
        )
        # Slider pour nb_ex_par_categorie
        nb_ex_slider = gr.Slider(
            minimum=0,
            maximum=5,
            value=2, # Valeur par d√©faut
            step=1,
            label="Nb Exemples par Cat√©gorie",
            info="Nombre d'exemples similaires √† afficher pour chaque cat√©gorie candidate."
        )
    # -----------------------------------------------

    # Bouton pour soumettre
    submit_button = gr.Button("Classifier l'Email")

    gr.Markdown("---") # S√©parateur visuel
    gr.Markdown("## R√©sultats de la classification")

    # --- NOUVEAU : Pr√©diction finale en premier ---
    # Zone de sortie pour la pr√©diction finale (plac√©e en haut des r√©sultats)
    output_prediction = gr.Textbox(label="Pr√©diction finale de la cat√©gorie", interactive=False)
    # ---------------------------------------------

    with gr.Row():
        # Zone de sortie pour les cat√©gories candidates (format JSON)
        output_categories_json = gr.JSON(label="Cat√©gories candidates (scores simul√©s)")

        # Zone de sortie pour les exemples candidats (format JSON)
        output_examples_json = gr.JSON(label="Exemples candidats (simul√©s)")


    # 3. Lier le bouton √† la fonction (avec les nouvelles entr√©es et sorties)
    submit_button.click(
        fn=classify_email_placeholder,
        # Ajout des sliders dans les inputs
        inputs=[email_input, top_k_slider, nb_ex_slider],
        # Mise √† jour de l'ordre et du type des outputs
        # 1. Pr√©diction (Textbox)
        # 2. Cat√©gories (JSON)
        # 3. Exemples (JSON)
        outputs=[output_prediction, output_categories_json, output_examples_json]
    )

# 4. Lancer l'application web
if __name__ == "__main__":
    demo.launch()


------------------------ VERSIO CLAUDE ------------------------------------------------------------------------------------------

import gradio as gr
import time # Juste pour simuler un petit d√©lai de traitement

# 1. Fonction de classification "vanilla" (placeholder)
def classify_email_placeholder(email_text):
    """
    Fonction de d√©monstration qui simule la classification d'un email.
    Prend le texte de l'email en entr√©e et retourne des donn√©es factices
    pour les cat√©gories candidates, les exemples et la pr√©diction finale.
    """
    print(f"Traitement de l'email : {email_text[:50]}...") # Affiche le d√©but de l'email dans la console

    # Simule un petit temps de traitement
    time.sleep(1)

    # Logique de classification factice :
    # Pour cette d√©mo, on retourne toujours les m√™mes valeurs.
    # Vous remplacerez cette partie par votre vraie logique de classification.
    if not email_text or len(email_text.strip()) == 0:
        return "N/A", "N/A", "Veuillez entrer le texte d'un email.", "#FFDDDD", "‚ö†Ô∏è Erreur"

    candidate_categories = "Commercial (Score: 0.6), Personnel (Score: 0.3), Spam (Score: 0.1)"
    candidate_examples = "Exemple 1 (similaire), Exemple 2 (diff√©rent), Exemple 3 (spam)"
    
    # La cat√©gorie jug√©e la plus probable
    final_prediction = "Commercial"
    
    # Couleur de fond en fonction de la pr√©diction
    if final_prediction == "Commercial":
        bg_color = "#E3F2FD" # Bleu clair
        icon = "üìä Commercial"
    elif final_prediction == "Personnel":
        bg_color = "#E8F5E9" # Vert clair
        icon = "üë§ Personnel"
    elif final_prediction == "Spam":
        bg_color = "#FFEBEE" # Rouge clair
        icon = "üö´ Spam"
    else:
        bg_color = "#F5F5F5" # Gris clair
        icon = "‚ùì Autre"

    print("Classification termin√©e.")

    # Retourne les cinq valeurs: cat√©gories, exemples, pr√©diction, couleur de fond et ic√¥ne
    return candidate_categories, candidate_examples, final_prediction, bg_color, icon

# 2. Cr√©ation de l'interface Gradio
with gr.Blocks(css="""
    .prediction-box { 
        font-size: 24px; 
        text-align: center; 
        padding: 20px; 
        border-radius: 10px; 
        margin-top: 10px;
        font-weight: bold;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
    }
    .result-section {
        margin-top: 20px;
    }
    .spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        margin-right: 10px;
    }
""") as demo:
    gr.Markdown("# üìß Classificateur d'Emails")
    gr.Markdown("Collez le contenu d'un email ci-dessous et cliquez sur 'Classifier' pour obtenir une pr√©diction de cat√©gorie.")

    with gr.Row():
        # Zone de saisie pour l'email
        email_input = gr.Textbox(
            lines=10,
            label="Email √† classifier",
            placeholder="Collez ici le contenu complet de l'email..."
        )

    # Bouton pour soumettre avec une ic√¥ne
    with gr.Row():
        submit_button = gr.Button("üîç Classifier l'Email", variant="primary", scale=2)

    # Section r√©sultats
    with gr.Row(visible=False) as result_container:
        gr.Markdown("## üìä R√©sultats de l'analyse", elem_classes=["result-section"])
    
    # Ajout d'une notification visuelle pendant le traitement
    loading_indicator = gr.HTML(visible=False, value="<div class='prediction-box' style='background-color: #F0F4F8;'><span class='spinner'>‚è≥</span> Classification en cours...</div>")
    
    # Zone visuelle pour la pr√©diction finale (avec mise en valeur)
    prediction_html = gr.HTML(visible=False, value="<div class='prediction-box'>R√©sultat de la classification</div>")
    
    # Zones moins visibles pour les d√©tails
    with gr.Accordion("D√©tails de la classification", open=False, visible=False) as details_accordion:
        output_categories = gr.Textbox(label="Cat√©gories candidates")
        output_examples = gr.Textbox(label="Exemples similaires")
        output_prediction_hidden = gr.Textbox(label="Pr√©diction brute", visible=False)
    
    # Variables de stockage (non visibles)
    bg_color = gr.Textbox(visible=False)
    prediction_icon = gr.Textbox(visible=False)

    # 3. Fonction pour afficher le r√©sultat avec animation
    def update_prediction_display(categories, examples, prediction, background_color, icon):
        # Afficher tous les √©l√©ments de r√©sultat
        result_html = f"""
        <div class='prediction-box' style='background-color: {background_color};'>
            <span style='font-size: 36px;'>{icon}</span><br>
            Classification: <span>{prediction}</span>
        </div>
        """
        return {
            result_container: gr.update(visible=True),
            loading_indicator: gr.update(visible=False),
            prediction_html: gr.update(visible=True, value=result_html),
            details_accordion: gr.update(visible=True),
            output_categories: categories,
            output_examples: examples,
            output_prediction_hidden: prediction,
            bg_color: background_color,
            prediction_icon: icon
        }
    
    # Fonction pour montrer l'indicateur de chargement
    def show_loading():
        return {
            loading_indicator: gr.update(visible=True),
            prediction_html: gr.update(visible=False),
            details_accordion: gr.update(visible=False)
        }

    # 4. Lier le bouton √† la fonction
    submit_button.click(
        fn=show_loading,
        inputs=None,
        outputs=[loading_indicator, prediction_html, details_accordion]
    ).then(
        fn=classify_email_placeholder,
        inputs=email_input,
        outputs=[output_categories, output_examples, output_prediction_hidden, bg_color, prediction_icon]
    ).then(
        fn=update_prediction_display,
        inputs=[output_categories, output_examples, output_prediction_hidden, bg_color, prediction_icon],
        outputs=[result_container, loading_indicator, prediction_html, details_accordion, 
                output_categories, output_examples, output_prediction_hidden, bg_color, prediction_icon]
    )

# 5. Lancer l'application web
if __name__ == "__main__":
    demo.launch()
